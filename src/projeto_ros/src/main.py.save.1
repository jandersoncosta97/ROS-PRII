#! /usr/bin/python3

import rospy
from math import pi, inf
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from geometry_msgs.msg import Twist
from trajectory_msgs.msg import JointTrajectory
# from camera import *

class myRobot():

	def __init__(self):
		print('init')
		# Subscriber Laser
		self.laser_sub = rospy.Subscriber('/scan_raw', LaserScan, self.callback_laser)
		self.distances = [0]*3
		
		# Subscriber Odometria
		self.odo_sub = rospy.Subscriber('/mobile_base_controller/odom', Odometry, self.callback_odometria, queue_size = 1)
		
		# Client Service Camera
		
#		self.camera_sub = MyCamera()

		# Publisher base
		self.cmd_pub = rospy.Publisher('mobile_base_controller/cmd_vel', Twist, queue_size = 1)
		
		# Publisher cabeca
		
		self_cmd_pub_head = rospy.Publisher('/head_controller/command', JointTrajectory, queue_size = 1)

		# speeds
		self.linear_speed = 2
		self.angular_speed  = 0


	def callback_odometria(self, msg):
		print('callback odometria')
		# Armazenar os dados de odometria
		qtn = msg.pose.pose.orientation
		qtn_list = [qtn.x, qtn.y, qtn.z, qtn.w]
		roll, pitch, yaw = euler_from_quaternion (qtn_list)
		print(roll, pitch, yaw)
		self.yaw = yaw

	def callback_laser(self, msg):
		print('callback laser')
		ranges = msg.ranges
		angle_min = msg.angle_min
		angle_increment = msg.angle_increment
		i = 0
		# Calculate indices for -90, 0, and 90 degrees
		angle_target = [-pi/2, 0, pi/2]
		for angle in angle_target:
			if angle >= msg.angle_min and angle <= msg.angle_max:
				index = int((angle - angle_min) / angle_increment)
				self.distances[i] = ranges[index]
			else:
				self.distances[i] = inf
			i+=1
		print(f'Distances at -90, 0, 90 degrees: {self.distances}')

	def moveStraight(self):
		print('move straight')
		move_cmd = Twist()
		move_cmd.linear.z = self.linear_speed
		self.cmd_pub.publish(move_cmd)
		
		# error = ...
		# while(abs(error) < value):

	def turn(self, orientation):
		print('turn')
		move_cmd = Twist()
		move_cmd.angular.z = orientation*pi
		self.cmd_pub.publish(move_cmd) 
		#move_cmd = Twist()
		# error = ...
		# while(abs(error) < value):

	def decision(self):
		print('decision')
		yaw = self.yaw+pi/2 
		uncertainty = pi/20
		while (self.distances[1] > 1.0):	
			self.moveStraight()
		# if (self.distances[0]) < (self.distances[2]):
		while yaw <= yaw+uncertainty or yaw >= yaw-uncertainty:
			self.turn(-1)
		# else:
		#	self.turn(1)

			
if __name__ == '__main__':
	rospy.init_node('TIAgoNODE')	
	rospy.Rate(1)
	tiago = myRobot()
	while not rospy.is_shutdown():
		tiago.decision()
		

      #  subObj = mySub()
       # While ROS is running
    

	#rospy.sleep(1)
	# while(...):
	# if state == 0:
	       	# decision
		# compute next state
	# else if state == 1
		# image porcessing
		# compute next state
	# else if state == 3
		# move straight
		# compute next state
	# else if state == 4
		# turn
		# compute next state
	
