#! /usr/bin/python3

import rospy
from math import pi, inf
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist

from tf.transformations import euler_from_quaternion, quaternion_from_euler

limiar = 0.3

class myRobot():

	def __init__(self):
		print('init')
		# Subscriber Laser
		rospy.Subscriber('/scan_raw', LaserScan, self.callback_laser)
		self.distances = [0]*3
		# Subscriber Odometria
		rospy.Subscriber('/mobile_base_controller/odom', Odometry, self.callback_odometria, queue_size = 1)
		# Client Service camera
		self.cmd_pub = rospy.Publisher('/cmd_devel', Twist, queue_size = 10)
		# Publisher base
		# Publisher cabeca
		self.linear_speed = 1
		self.angular_speed = 0.2
		self.state = 0
	
	def callback_odometria(self, msg):
		print('callback odometria')
		# Armazenar os dados de odometria
		qtn = msg.pose.pose.orientation
		qtn_list = [qtn.x, qtn.y, qtn.z, qtn.w]
		(roll, pitch, yaw) = euler_from_quaternion (qtn_list)
		print(roll, pitch, yaw)

	def callback_laser(self, msg):
		print('callback laser')
		ranges = msg.ranges
		angle_min = msg.angle_min
		angle_increment = msg.angle_increment
		i = 0
		# Calculate indices for -90, 0, and 90 degrees
		angle_target = [-pi/2, 0, pi/2]
		for angle in angle_target:
			if angle >= msg.angle_min and angle <= msg.angle_max:
				index = int((angle - angle_min) / angle_increment)
				self.distances[i] = ranges[index]
			else:
				self.distances[i] = float('inf')
			i+=1
		print(f'Distances at -90, 0, 90 degrees: {self.distances}')

	def moveStraight(self):
		print('move straight')
		move_cmd = Twist()
		move_cmd.linear.x = self.linear_speed
		move_cmd.angular.z = 0.0
        move_cmd = Twist()
        move_cmd.linear.x = 0.0
        move_cmd.angular.z = sens * self.angular_speed
        self.cmd_pub.publish(move_cmd)		self.cmd_pub.publish(move_cmd)
		# error = ...
		# while(abs(error) < value):

	def turn(self, sens):
		print('turn')


		# error = ...
		# while(abs(error) < value):

	def decision(self):
		print('decision')
        	if (self.distances[1] < limiar) and (self.distances[0] < 1.5) and (self.distances[2] < 1.5):
			tiago.state = 3
		elif (self.distances[1] != inf) and ((self.distances[0] != inf) or (self.distances[2] != inf):
			tiago.state = 4	 


if __name__ == '__main__':

	rospy.init_node('nodeName')

	tiago = myRobot()

	while not rospy.is_shutdown():
		if tiago.state == 0:
	       		tiago.decision()
		elif tiago.state == 3:
			tiago.moveStraight()
		elif tiago.state == 4:
			tiago.turn(1) # to the right
		elif tiago.state == 5:
			tiago.turn(
		rospy.sleep(0.1)

		# compute next state
	# else if state == 1
		# image porcessing
		# compute next state
	# else if state == 3
		# move straight
		# compute next state
	# else if state == 4
		# turn
		# compute next state
	

